<!DOCTYPE html>
<html>
<head>
</style>
</head>
<body>
<div style="text-align:center; width:100%">
  <div style="height:500px;width:1000px;margin:auto;padding-top:100px;">
  <svg id='mainCanvas' height="500" width="800">
    <g id='test1'>
    <rect x="20", y="120", width="100" height="100" style="fill:rgb(255,255,255);stroke-width:2;stroke:rgb(0,0,0)" />
    <text x="70" y="170" dominant-baseline="middle" text-anchor="middle">TEXT</text>
    </g>
    <g id='test2'>
    <rect x="150", y="120", width="100" height="100" style="fill:rgb(255,255,255);stroke-width:2;stroke:rgb(0,0,0)" />
    </g>
  </svg>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.0.2/anime.min.js"></script>
<script>
  // The number array to be sorted.
  // Please change it here if you want to animate the sorting of another array.
  const NUM_VALUE_ARRAY = [6, 5, 3, 2, 8, 1];

  // Config of the layout
  // @param {Number} canvasWidth - the width of the svg canvas
  // @return
  //  object {
  //    numberBoxWidth: the width of the rectangle boxes holding the number
  //    numberBoxGap: the gap between the rectangle boxes holding the number
  //    numberBoxBorderWidth: the border width of the box
  //  }
  const LAYOUT_CONFIG = (function(canvasWidth){
    // The ratio of numberBoxGap:numberBoxWidth
    const gapRatio = 0.3;
    // The border of elemnt box
    const numberBoxBorderWidth = 2;
    // The gap also applies in the front and at the end of the boxes within the canvas.
    // So let numberBoxWidth=x, then num_boxes * x + 0.3 * (num_boxes + 1) * x = canvas_width.
    // Therefore we have, (1.3 * num_boxes + 0.3) * x = canvas_width => x = canvas_width/(1.3 * num_boxes + 0.3)
    const numberBoxWidth = Math.round(canvasWidth / ((1 + gapRatio) * NUM_VALUE_ARRAY.length + gapRatio));
    return {
      numberBoxWidth: numberBoxWidth,
      numberBoxGap: Math.round(numberBoxWidth * gapRatio),
      numberBoxBorderWidth: numberBoxBorderWidth
    };
  })(parseInt(document.getElementById("mainCanvas").getAttribute("width")));
  console.log(LAYOUT_CONFIG);
  /**
   * ElementToSort class.
   *
   * @constructor
   * @param {String} svgNode - Dom node to represent the element to sort. Should be a <g> node.
   * @param {Number} value  - Value in this node.
   */
  class ElementToSort {
    constructor(svgNode, value) {
      this.svgNode = svgNode;
      this.value = value;
    }
  }

  // Init the svg canvas by drawing boxes of elements in NUM_VALUE_ARRAY
  // @param {String} svgId - the id of svg node
  // return an array of ElementToSort
  function initSVG(svgId){

  }

  function swapNeighbor(eleLeft, eleRight, dx, dy, duration){
    const positionLeft = [
      {
        x: '+=0',
        y: '-='+dy.toString(),
      },
      {
        x: '+='+dx.toString(),
        y: '+=0',
      },
      {
        x: '-=0',
        y: '+='+dy.toString(),
      }
    ];
    const positionRight = [
      {
        x: '+=0',
        y: '+='+dy.toString(),
      },
      {
        x: '-='+dx.toString(),
        y: '+=0',
      },
      {
        x: '-=0',
        y: '-='+dy.toString(),
      }
    ];
    anime({
      targets: eleLeft,
      easing: 'easeInOutSine',
      translateX: positionLeft.map(p => ({value: p.x, duration})),
      translateY: positionLeft.map(p => ({value: p.y, duration})),
    });
    anime({
      targets: eleRight,
      easing: 'easeInOutSine',
      translateX: positionRight.map(p => ({value: p.x, duration})),
      translateY: positionRight.map(p => ({value: p.y, duration})),
    });
  }
  
  swapNeighbor("#test1", "#test2", 130, 60, 1000);
  
</script>
</body>
</html>